#!/bin/bash -e

### expect assembly-specific config file as argument 
cfg=$1 

if [[ ! -f ${cfg} ]]
then 
	(>&2 echo "[ERROR] DAmar.cfg requires the assembly-specific config file as argument! See exampleConfig.sh in the scripts directory ${SUBMIT_SCRIPTS_PATH}!")
     exit 1
fi

source ${cfg}

# always set current working directory (is required in most steps of each pipeline)
myCWD=$(pwd)

if [[ -z "${DB_OUTDIR}" ]]
then
	DB_OUTDIR="db"
fi

if [[ -z "${QC_OUTDIR}" ]]
then
	QC_OUTDIR="qc"
fi

if [[ -z "${CCS_NCHUNKS}" ]]
then
	CCS_NCHUNKS=10
fi

if [[ -z "${MIN_PACBIO_RLEN}" ]]
then
	MIN_PACBIO_RLEN=4000
fi

if [[ -z "${DBSPLIT_SIZE}" ]]
then
	DBSPLIT_SIZE=400
fi

if [[ -z "${RAW_REPMASK_OUTDIR}" ]]
then
	RAW_REPMASK_OUTDIR=repmask	
fi

# set some default variables
if [[ -z ${FIX_DALIGN_OUTDIR} ]]
then
	FIX_DALIGN_OUTDIR="dalign"
fi

if [[ -z ${FIX_REPCOMP_OUTDIR} ]]
then
	FIX_REPCOMP_OUTDIR="repcomp"
fi

if [[ -z ${FIX_FORCEALIGN_OUTDIR} ]]
then
	FIX_FORCEALIGN_OUTDIR="forcealign"
fi

# todo: only set this for appropriate phases
if [[ ${FIX_SCRUB_TYPE} -eq 0 ]]
then 
	FIX_SCRUB_NAME="${FIX_DALIGN_OUTDIR}"
elif [[ ${FIX_SCRUB_TYPE} -eq 1 ]]
then 
	FIX_SCRUB_NAME="${FIX_REPCOMP_OUTDIR}"
elif [[ ${FIX_SCRUB_TYPE} -eq 2 ]]
then 
	FIX_SCRUB_NAME="${FIX_FORCEALIGN_OUTDIR}"
else
	(>&2 echo "[ERROR] DAmar.cfg: Scrubbing Type: ${FIX_SCRUB_TYPE} unsupported!")
    exit 1		
fi

if [[ -z ${COR_DIR} ]]
then 
    COR_DIR=correction
fi

if [[ -z "${PACBIO_TYPE}" ]]
then
	(>&2 echo "[WARNING] DAmar.cfg: Variable PACBIO_TYPE is not set! Set PACBIO_TYPE to default value: LoFi!")
	PACBIO_TYPE="LoFi"
fi 

if [[ -n ${GSIZE} ]]
then
	gsize=${GSIZE}
	i=$((${#GSIZE}-1))
	if [[ "${GSIZE: -1}" =~ [gG] ]]
	then
	 gsize=$((${GSIZE:0:$i}*1000*1000*1000))
	fi
	if [[ "${GSIZE: -1}" =~ [mM] ]]
	then
	 gsize=$((${GSIZE:0:$i}*1000*1000))
	fi
	if [[ "${GSIZE: -1}" =~ [kK] ]]
	then
	 gsize=$((${GSIZE:0:$i}*1000))
	fi
fi

### available pipelines 

### INIT - create DB's, data QC and stats pipelines 
#type-0 [10x - init] 							[1-4]: longrangerBasic, longrangerToScaff10Xinput, bxcheck, createStats
#type-1 [PacBio LoFi Init] 						[1-4]: bam2fasta createDB createStats
#type-2 [PacBio HiFi Init] 						[1-3]: createSubdir ccs samtoolsMerge bam2fasta createDB createStats
#type-3 [HiC - init]							[1-1]: createStats 
#type-4 [Bionano - init]						[1-1]: createStats???
#type-5 [10x - de novo] 						[1-1]: 01_supernova
#type-6 [10x|HiC - kmer-Gsize estimate] 		[1-2]: 01_genomescope
#type-7 [allData - MASH CONTAMINATION SCREEN] 	[1-5]: 01_mashPrepare, 02_mashSketch, 03_mashCombine, 04_mashPlot, 05_mashScreen
#type-8 [10x - QV]   							[1-6]: 01_QVprepareInput, 02_QVlongrangerAlign, 03_QVcoverage, 04_QVfreebayes, 05_QVbcftools, 06_QVqv
init_type_0=(createSubdir longrangerBasic longrangerToScaff10Xinput bxcheck createStats)
init_type_1=(bam2fasta createDB createStats)
init_type_2=(createSubdir ccs samtoolsMerge bam2fasta createDB createStats)
init_type_3=(createSubdir createStats)
init_type_4=(createSubdir createStats)
init_type_5=(createSubdir supernova)
init_type_6=(createSubdir genomescope)
init_type_7=(createSubdir mashPrepare mashSketch mashCombine mashPlot mashScreen)
init_type_8=(createSubdir QVprepareInput QVlongrangerAlign QVcoverage QVfreebayes QVbcftools QVqv)

### MITO ASSEMBLY PIPELINE

### LAS repeat masking
#type-0 - steps[1-14]: createSubdir DBdust Catrack datander TANmask Catrack daligner LAmerge LArepeat TKmerge daligner LAmerge LArepeat TKmerge
rmask_type_0=(createSubdir DBdust Catrack datander TANmask Catrack daligner LAmerge LArepeat TKmerge daligner LAmerge LArepeat TKmerge)

### LAS read patching 

### LAS repeat masking

### LAS scrubbing
#type-0 - steps[1-14]: dalign pipeline
#type-1 - steps[1-15]: repcomp pipeline
#type-2 - steps[1-15]: forcealign pipeline

ScrubType_0=(createSubdir daligner LAmerge LArepeat TKmerge TKcombine TKhomogenize TKcombine LAstitch LAq TKmerge LAgap LAq TKmerge)
ScrubType_1=(createSubdir LAseparate repcomp LAmerge LArepeat TKmerge TKcombine TKhomogenize TKcombine LAstitch LAq TKmerge LAgap LAq TKmerge)
ScrubType_2=(createSubdir LAseparate forcealign LAmerge LArepeat TKmerge TKcombine TKhomogenize TKcombine LAstitch LAq TKmerge LAgap LAq TKmerge)

### LAS filtering 
#FiltType_0 - steps[1-3]: default pipeline
#FiltType_1 - steps[1-3]: experimental pipeline 1
#FiltType_2 - steps[1-14]: experimental pipeline 2 (daccord)

FiltType_0=(createSubdir LAfilter LAmerge)
FiltType_1=(createSubdir LAfilterChains LAmerge)
FiltType_2=(createSubdir computeIntrinsicQV Catrack lasdetectsimplerepeats mergeAndSortRepeats lasfilteralignments mergesym2 filtersym lasfilteralignmentsborderrepeats mergesym2 filtersym filterchainsraw LAfilter LAmerge)

### Touring
#TourType_0 - steps[1-5]: default pipeline 
TourType_0=(OGbuild OGtour tour2fasta OGlayout statistics)

### DAmar Correction 
#CorrType_0 - stepsp[1-5] 1-paths2rids, 2-LAcorrect, 3-prepDB, 4-tour2fasta, 5-statistics
CorrType_0=(paths2rids LAcorrect prepDB tour2fasta statistics)

### some general functions

function getNumOfDbBlocks()
{
    db=$1
    if [[ ! -f $db ]]
    then
        (>&2 echo "database $db not found")
        exit 1
    fi

    blocks=$(grep block $db | awk '{print $3}')
    if [[ ! -n $blocks ]]
    then 
        (>&2 echo "database $db has not been partitioned. Run DBsplit first!")
        exit 1
    fi 
    echo ${blocks}
}


function getStepName ()
{
	 if [[ $# -ne 3 ]]
	 then
	   (>&2 echo "[ERROR] DAmar.cfg: getStepName() invalid number of arguments: ($#) Expected 3!");
	   exit 1
	 fi
	 TMP="${1}_type_${2}"
	 if [[ -v "${!TMP}" ]]
	 then
	    (>&2 echo "[ERROR] DAmar.cfg: getStepName() $1 Type: ${TMP} is not available");
	    exit 1
	 fi
	 if [[ $3 -lt 0 || $3 -ge $(eval echo \${#$(echo ${TMP})[@]}) ]]
	 then 
	    (>&2 echo "[ERROR] DAmar.cfg: getStepName() $1 Type: ${TMP}: Unsupported step $3! ${TMP} has only steps [1-$(eval echo \${#$(echo ${TMP})[@]}))");
	    exit 1 
	 fi;                    
	 eval echo \${$(echo ${TMP})[${3:-@}]};
}

function isNumber 
{
  if [[ "$1" =~ ^[0-9]+$ ]]
  then 
    return 0
  else 
    return 1
  fi
}


function prependZero ()
{
 	if [[ $# -ne 1 ]]
 	then 
	   (>&2 echo "[ERROR] DAmar.cfg: prependZero() invalid number of arguments: $# Expected 1! ");
   		exit 1
 	fi 
 	
 	isNumber $1
 	
 	if [[ $1 -lt 10 ]]
 	then
 		echo -n "0$1"
 	else
 		echo -n "$1"
 	fi 	
}


# file must be present 
function realpath()
{
	echo "$(cd "$(dirname "$1")"; pwd)/$(basename "$1")"
}


function pipelineNameToID()
{
	if [[ $# -ne 1 ]]
	then 
	   (>&2 echo "[ERROR] DAmar.cfg: pipelineNameToID() invalid number of arguments: $# Expected 1! ");
   		exit 1
 	fi 
 	
	if [[ "$1" == "init" ]]
    then
        echo -n "0"
	elif [[ "$1" == "mito" ]]
    then
        echo -n "1"
	elif [[ "$1" == "cover" ]]
    then
        echo -n "2"
    elif [[ "$1" == "rmask" ]]
    then
        echo -n "3"
    elif [[ "$1" == "fix" ]]
    then
        echo -n "4"
    elif [[ "$1" == "fmask" ]]
    then
        echo -n "5"
	elif [[ "$1" == "scrub" ]]
    then
        echo -n "6"
	elif [[ "$1" == "filt" ]]
    then
        echo -n "7"
    elif [[ "$1" == "tour" ]]
    then
        echo -n "8"
	elif [[ "$1" == "corr" ]]
    then
        echo -n "9"
    elif [[ "$1" == "cont" ]]
    then
        echo -n "10"
    elif [[ "$1" == "arrow" ]]
    then
        echo -n "11"
    elif [[ "$1" == "pDups" ]]
    then
        echo -n "12"
    elif [[ "$1" == "freebayes" ]]
    then
        echo -n "13"
    elif [[ "$1" == "phase" ]]
    then
        echo -n "14"
    elif [[ "$1" == "s10x" ]]
    then
        echo -n "15"
    elif [[ "$1" == "sbionano" ]]
    then
        echo -n "16" 
    elif [[ "$1" == "shic" ]]
    then
        echo -n "17"
    else
        (>&2 echo "[ERROR] DAmar_slurm: unknown phase ${currentPhase}! Supported values (qc, mito, cover, rmask, fix, fmask, scrub, filt, tour, corr, cont, arrow, pDups, freebayes, phase, s10x, sbionano, shic)")
        exit 1
    fi
}

function pipelineIDToName()
{
	if [[ $# -ne 1 ]]
	then 
	   (>&2 echo "[ERROR] DAmar.cfg: pipelineIDToName() invalid number of arguments: $# Expected 1! ");
   		exit 1
 	fi 
 	
 	if ! $(isNumber $1)
	then
		(>&2 echo "[ERROR] DAmar.cfg: pipelineIDToName(): Argument $1 must be a positive number!!")
		exit 1
	fi
 	
 	if [[ $1 -eq 0 ]]
    then
        echo -n "init"
	elif [[ $1 -eq 1 ]]
    then
        echo -n "mito"
	elif [[ $1 -eq 2 ]]
    then
        echo -n "cover"
    elif [[ $1 -eq 3 ]]
    then
        echo -n "rmask"
    elif [[ $1 -eq 4 ]]
    then
        echo -n "fix"
    elif [[ $1 -eq 5 ]]
    then
        echo -n "fmask"
	elif [[ $1 -eq 6 ]]
    then
        echo -n "scrub"
	elif [[ $1 -eq 6 ]]
    then
        echo -n "filt"
    elif [[ $1 -eq 8 ]]
    then
        echo -n "tour"
	elif [[ $1 -eq 9 ]]
    then
        echo -n "corr"
    elif [[ $1 -eq 10 ]]
    then
        echo -n "cont"
    elif [[ $1 -eq 11 ]]
    then
        echo -n "arrow"
    elif [[ $1 -eq 12 ]]
    then
        echo -n "pDups"
    elif [[ $1 -eq 13 ]]
    then
        echo -n "freebayes"
    elif [[ $1 -eq 14 ]]
    then
        echo -n "phase"
    elif [[ $1 -eq 15 ]]
    then
        echo -n "s10x"
    elif [[ $1 -eq 16 ]]
    then
        echo -n "sbionano" 
    elif [[ $1 -eq 17 ]]
    then
        echo -n "shic"
    else
        (>&2 echo "[ERROR] DAmar_slurm: unknown phase ${currentPhase}! Supported values (0-17)")
        exit 1
    fi
}

function getPipelineDir()
{
	if [[ $# -ne 1 ]]
	then 
	   (>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() invalid number of arguments: $# Expected 1! ");
   		exit 1
 	fi 
 	
 	if ! $(isNumber $1)
 	then
 	 	(>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() invalid argument: $1! Must be a positive number!");
   		exit 1
 	fi

	if [[ $1 -eq 0 ]]
	then
		if [[ -z "${INIT_DIR}" ]]
		then 
    		(>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() You have to set variable INIT_DIR")
    		exit 1
		fi 
	
		echo -n "${INIT_DIR}"
	elif [[ $1 -eq 1 ]]
	then
		if [[ -z "${MITO_DIR}" ]]
		then 
    		(>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() You have to set variable MITO_DIR")
    		exit 1
		fi 
	
		echo -n "${MITO_DIR}"
	elif [[ $1 -gt 2 && $1 -lt 5 ]]
	then
		if [[ -z "${PATCHING_DIR}" ]]
		then 
    		(>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() You have to set variable PATCHING_DIR")
    		exit 1
		fi 
	
		echo -n "${PATCHING_DIR}"
	elif [[ $1 -gt 2 && $1 -lt 5 ]]
	then
		if [[ -z "${PATCHING_DIR}" ]]
		then 
    		(>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() You have to set variable PATCHING_DIR")
    		exit 1
		fi 
	
		echo -n "${PATCHING_DIR}"
	elif [[ $1 -gt 2 && $1 -lt 5 ]]
	then
		if [[ -z "${ASSMEBLY_DIR}" ]]
		then 
		    (>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() You have to set variable ASSMEBLY_DIR")
		    exit 1
		fi
	
		if [[ "${ASSMEBLY_DIR}" == "${PATCHING_DIR}" ]]
		then 
		    (>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() PATCHING_DIR must be different from ASSMEBLY_DIR")
		    exit 1
		fi
	
		if [[ -z "${FIX_REPMASK_USELAFIX_PATH}" ]]
		then 
			(>&2 echo "[WARNING] DAmar.cfg: getPipelineDir() Variable FIX_REPMASK_USELAFIX_PATH is not set.Try to use default path: patchedReads_dalign")
			FIX_REPMASK_USELAFIX_PATH="patchedReads_dalign"
		fi
		
		echo -n "${ASSMEBLY_DIR}_${FIX_REPMASK_USELAFIX_PATH}"		
	else
		 (>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() DAmar pipeline $1 is not yet supported!")
		  exit 1
	fi
}


function ensureAndEnterPipelineDir()
{
	if [[ $# -ne 1 ]]
	then 
	   (>&2 echo "[ERROR] DAmar.cfg: ensureAndEnterPipelineDir() invalid number of arguments: $# Expected 1! ");
   		exit 1
 	fi 
 	
 	d=$(getPipelineDir $1)
 	mkdir -p ${d}
	cd ${d}
}

function getNextPipelineStep()
{
	if [[ $# -ne 2 ]]
	then 
	   (>&2 echo "[ERROR] DAmar.cfg: getNextPipelineStep() invalid number of arguments: $# Expect 2 arguments pipelineIdx and pipelineStepId}! ");
   		exit 1
 	fi 
 	
 	local pipelineIdx=$1	
 	local pipelineStepId=$2

	nextStep=$((pipelineStepId+1))
	
	if [[ ${nextStep} -le ${RUN_DAMAR[$((pipelineIdx+3))]} ]] 
	then
		echo -n "${nextStep}"
	else
		echo -n "-1"
	fi	
}

function getNextPipelineIndex()
{
	if [[ $# -ne 2 ]]
	then 
	   (>&2 echo "[ERROR] DAmar.cfg: getNextPipelineIndex() invalid number of arguments: $# Expect 2 arguments pipelineIdx and pipelineID}! ");
   		exit 1
 	fi 
 	
 	local pipelineIdx=$1	
 	local pipelineID=$2
 	
 	nextPipelineIdx=$((pipelineIdx+5))
 	while [[ ${nextPipelineIdx} -lt ${#RUN_DAMAR[@]} ]]
 	do
 		if [[ ${RUN_DAMAR[$((nextPipelineIdx+4))]} -eq ${pipelineID} ]] 
 		then
 			echo -n "${nextPipelineIdx}"
 			break	
 		fi 
 	done 

	if [[ ${pipelineIdx} -ge ${#RUN_DAMAR[@]} ]]
	then
		echo -n "-1"
	fi 
}