#!/bin/bash -e

### expect assembly-specific config file as argument 
cfg=$1 

if [[ ! -f ${cfg} ]]
then 
	(>&2 echo "[ERROR] DAmar.cfg requires the assembly-specific config file as argument! See exampleConfig.sh in the scripts directory ${SUBMIT_SCRIPTS_PATH}!")
     exit 1
fi

source ${cfg}

# always set current working directory (is required in most steps of each pipeline)
myCWD=$(pwd)

if [[ -z "${DB_OUTDIR}" ]]
then
	DB_OUTDIR="db"
fi

if [[ -z "${QC_OUTDIR}" ]]
then
	QC_OUTDIR="qc"
fi

if [[ -z "${CCS_NCHUNKS}" ]]
then
	CCS_NCHUNKS=10
fi

if [[ -z "${MIN_PACBIO_RLEN}" ]]
then
	MIN_PACBIO_RLEN=4000
fi

if [[ -z "${DBSPLIT_SIZE}" ]]
then
	DBSPLIT_SIZE=400
fi

if [[ -z "${REPMASK_OUTDIR}" ]]
then
	REPMASK_OUTDIR=repmask	
fi

# set some default variables
if [[ -z ${DALIGN_OUTDIR} ]]
then
	DALIGN_OUTDIR="dalign"
fi

if [[ -z ${REPCOMP_OUTDIR} ]]
then
	REPCOMP_OUTDIR="repcomp"
fi

if [[ -z ${FORCEALIGN_OUTDIR} ]]
then
	FORCEALIGN_OUTDIR="forcealign"
fi

if [[ -z ${DACCORD_OUTDIR} ]]
then
	DACCORD_OUTDIR="daccord"
fi

if [[ -z ${DACCORD_INDIR} ]]
then
	DACCORD_INDIR="dalign"
elif [[ "${DACCORD_INDIR}" !=  "${DALIGN_OUTDIR}" && "${DACCORD_INDIR}" !=  "${REPCOMP_OUTDIR}" && "${DACCORD_INDIR}" !=  "${FORCEALIGN_OUTDIR}" ]]
then 
	(>&2 echo "[WARNING] DAmar.cfg: Variable DACCORD_INDIR: ${DACCORD_INDIR} not supported! Must match a previously created pipeline out directory: e.g. ${DALIGN_OUTDIR} or ${REPCOMP_OUTDIR} or ${FORCEALIGN_OUTDIR}!")
	exit 1
fi


# todo: only set this for appropriate phases
if [[ ${FIX_SCRUB_TYPE} -eq 0 ]]
then 
	FIX_SCRUB_NAME="${FIX_DALIGN_OUTDIR}"
elif [[ ${FIX_SCRUB_TYPE} -eq 1 ]]
then 
	FIX_SCRUB_NAME="${FIX_REPCOMP_OUTDIR}"
elif [[ ${FIX_SCRUB_TYPE} -eq 2 ]]
then 
	FIX_SCRUB_NAME="${FIX_FORCEALIGN_OUTDIR}"
else
	(>&2 echo "[ERROR] DAmar.cfg: Scrubbing Type: ${FIX_SCRUB_TYPE} unsupported!")
    exit 1		
fi

if [[ -z ${COR_DIR} ]]
then 
    COR_DIR=correction
fi

if [[ -z "${PACBIO_TYPE}" ]]
then
	(>&2 echo "[WARNING] DAmar.cfg: Variable PACBIO_TYPE is not set! Set PACBIO_TYPE to default value: LoFi!")
	PACBIO_TYPE="LoFi"
fi 

if [[ -n ${GSIZE} ]]
then
	gsize=${GSIZE}
	i=$((${#GSIZE}-1))
	if [[ "${GSIZE: -1}" =~ [gG] ]]
	then
	 gsize=$((${GSIZE:0:$i}*1000*1000*1000))
	fi
	if [[ "${GSIZE: -1}" =~ [mM] ]]
	then
	 gsize=$((${GSIZE:0:$i}*1000*1000))
	fi
	if [[ "${GSIZE: -1}" =~ [kK] ]]
	then
	 gsize=$((${GSIZE:0:$i}*1000))
	fi
fi

### available pipelines 

### INIT - create DB's, data QC and stats pipelines 
#type-0 [10x - init] 							[1-4]: longrangerBasic, longrangerToScaff10Xinput, bxcheck, createStats
#type-1 [PacBio LoFi Init] 						[1-4]: bam2fasta createDB createStats
#type-2 [PacBio HiFi Init] 						[1-3]: createSubdir ccs samtoolsMerge bam2fasta createDB createStats
#type-3 [HiC - init]							[1-1]: createStats 
#type-4 [Bionano - init]						[1-1]: createStats???
#type-5 [10x - de novo] 						[1-1]: 01_supernova
#type-6 [10x|HiC - kmer-Gsize estimate] 		[1-2]: 01_genomescope
#type-7 [allData - MASH CONTAMINATION SCREEN] 	[1-5]: 01_mashPrepare, 02_mashSketch, 03_mashCombine, 04_mashPlot, 05_mashScreen
#type-8 [10x - QV]   							[1-6]: 01_QVprepareInput, 02_QVlongrangerAlign, 03_QVcoverage, 04_QVfreebayes, 05_QVbcftools, 06_QVqv
init_type_0=(createSubdir longrangerBasic longrangerToScaff10Xinput bxcheck createStats)
init_type_1=(bam2fasta createDB createStats)
init_type_2=(createSubdir ccs samtoolsMerge bam2fasta createDB createStats)
init_type_3=(createSubdir createStats)
init_type_4=(createSubdir createStats)
init_type_5=(createSubdir supernova)
init_type_6=(createSubdir genomescope)
init_type_7=(createSubdir mashPrepare mashSketch mashCombine mashPlot mashScreen)
init_type_8=(createSubdir QVprepareInput QVlongrangerAlign QVcoverage QVfreebayes QVbcftools QVqv)

### MITO ASSEMBLY PIPELINE

### LAS repeat masking
#type-0 - steps[1-14]: createSubdir DBdust Catrack datander TANmask Catrack daligner LAmerge LArepeat TKmerge daligner LAmerge LArepeat TKmerge
rmask_type_0=(createSubdir DBdust Catrack datander TANmask Catrack daligner LAmerge LArepeat TKmerge daligner LAmerge LArepeat TKmerge)

### LAS read patching 
fix_type_0=(createSubdir daligner LAmerge LArepeat TKmerge TKcombine LAfilter LAq TKmerge LAfix)
fix_type_1=(createSubdir LAseparate repcomp LAmerge LArepeat TKmerge TKcombine LAq TKmerge LAfix)
fix_type_2=(createSubdir lassort2 computeIntrinsicQV Catrack lasdetectsimplerepeats mergeAndSortRepeats lasfilteralignments mergesym2 filtersym lasfilteralignmentsborderrepeats mergesym2 filtersym filterchainsraw LAfilterChains LAfilter split LAmerge LAfix)
fix_type_3=(patchStats)

### LAS repeat masking

### LAS scrubbing
#type-0 - steps[1-14]: dalign pipeline
#type-1 - steps[1-15]: repcomp pipeline
#type-2 - steps[1-15]: forcealign pipeline

ScrubType_0=(createSubdir daligner LAmerge LArepeat TKmerge TKcombine TKhomogenize TKcombine LAstitch LAq TKmerge LAgap LAq TKmerge)
ScrubType_1=(createSubdir LAseparate repcomp LAmerge LArepeat TKmerge TKcombine TKhomogenize TKcombine LAstitch LAq TKmerge LAgap LAq TKmerge)
ScrubType_2=(createSubdir LAseparate forcealign LAmerge LArepeat TKmerge TKcombine TKhomogenize TKcombine LAstitch LAq TKmerge LAgap LAq TKmerge)

### LAS filtering 
#FiltType_0 - steps[1-3]: default pipeline
#FiltType_1 - steps[1-3]: experimental pipeline 1
#FiltType_2 - steps[1-14]: experimental pipeline 2 (daccord)

FiltType_0=(createSubdir LAfilter LAmerge)
FiltType_1=(createSubdir LAfilterChains LAmerge)
FiltType_2=(createSubdir computeIntrinsicQV Catrack lasdetectsimplerepeats mergeAndSortRepeats lasfilteralignments mergesym2 filtersym lasfilteralignmentsborderrepeats mergesym2 filtersym filterchainsraw LAfilter LAmerge)

### Touring
#TourType_0 - steps[1-5]: default pipeline 
TourType_0=(OGbuild OGtour tour2fasta OGlayout statistics)

### DAmar Correction 
#CorrType_0 - stepsp[1-5] 1-paths2rids, 2-LAcorrect, 3-prepDB, 4-tour2fasta, 5-statistics
CorrType_0=(paths2rids LAcorrect prepDB tour2fasta statistics)

### some general functions

function getNumOfDbBlocks()
{
    db=$1
    if [[ ! -f $db ]]
    then
        (>&2 echo "[ERROR] DAmar.cfg - getNumOfDbBlocks(): database $db not found")
        exit 1
    fi

    blocks=$(grep block $db | awk '{print $3}')
    if [[ ! -n $blocks ]]
    then 
        (>&2 echo "[ERROR] DAmar.cfg - getNumOfDbBlocks(): database $db has not been partitioned. Run DBsplit first!")
        exit 1
    fi 
    echo ${blocks}
}


function getStepName ()
{
	 if [[ $# -ne 3 ]]
	 then
	   (>&2 echo "[ERROR] DAmar.cfg: getStepName() invalid number of arguments: ($#) Expected 3!");
	   exit 1
	 fi
	 local TMP="${1}_type_${2}"
	 if [[ -v "${!TMP}" ]]
	 then
	    (>&2 echo "[ERROR] DAmar.cfg: getStepName() $1 Type: ${TMP} is not available");
	    exit 1
	 fi
	 if [[ $3 -lt 0 || $3 -ge $(eval echo \${#$(echo ${TMP})[@]}) ]]
	 then 
	    (>&2 echo "[ERROR] DAmar.cfg: getStepName() $1 Type: ${TMP}: Unsupported step $3! ${TMP} has only steps [1-$(eval echo \${#$(echo ${TMP})[@]}))");
	    exit 1 
	 fi;                    
	 eval echo \${$(echo ${TMP})[${3:-@}]};
}

function isNumber 
{
  if [[ "$1" =~ ^[0-9]+$ ]]
  then 
    return 0
  else 
    return 1
  fi
}

function isFloatNumber 
{
  if [[ "$1" =~ ^[-+]?[0-9]*.[0-9]*$ ]]
  then 
    return 0
  else 
    return 1
  fi
}

function prependZero ()
{
 	if [[ $# -ne 1 ]]
 	then 
	   (>&2 echo "[ERROR] DAmar.cfg: prependZero() invalid number of arguments: $# Expected 1! ");
   		exit 1
 	fi 
 	
 	isNumber $1
 	
 	if [[ $1 -lt 10 ]]
 	then
 		echo -n "0$1"
 	else
 		echo -n "$1"
 	fi 	
}


# file must be present 
function realpath()
{
	echo "$(cd "$(dirname "$1")"; pwd)/$(basename "$1")"
}


function pipelineNameToID()
{
	if [[ $# -ne 1 ]]
	then 
	   (>&2 echo "[ERROR] DAmar.cfg: pipelineNameToID() invalid number of arguments: $# Expected 1! ");
   		exit 1
 	fi 
 	
	if [[ "$1" == "init" ]]
    then
        echo -n "0"
	elif [[ "$1" == "mito" ]]
    then
        echo -n "1"
	elif [[ "$1" == "cover" ]]
    then
        echo -n "2"
    elif [[ "$1" == "rmask" ]]
    then
        echo -n "3"
    elif [[ "$1" == "fix" ]]
    then
        echo -n "4"
    elif [[ "$1" == "fmask" ]]
    then
        echo -n "5"
	elif [[ "$1" == "scrub" ]]
    then
        echo -n "6"
	elif [[ "$1" == "filt" ]]
    then
        echo -n "7"
    elif [[ "$1" == "tour" ]]
    then
        echo -n "8"
	elif [[ "$1" == "corr" ]]
    then
        echo -n "9"
    elif [[ "$1" == "cont" ]]
    then
        echo -n "10"
    elif [[ "$1" == "arrow" ]]
    then
        echo -n "11"
    elif [[ "$1" == "pDups" ]]
    then
        echo -n "12"
    elif [[ "$1" == "freebayes" ]]
    then
        echo -n "13"
    elif [[ "$1" == "phase" ]]
    then
        echo -n "14"
    elif [[ "$1" == "s10x" ]]
    then
        echo -n "15"
    elif [[ "$1" == "sbionano" ]]
    then
        echo -n "16" 
    elif [[ "$1" == "shic" ]]
    then
        echo -n "17"
    else
        (>&2 echo "[ERROR] DAmar_slurm: unknown phase ${currentPhase}! Supported values (qc, mito, cover, rmask, fix, fmask, scrub, filt, tour, corr, cont, arrow, pDups, freebayes, phase, s10x, sbionano, shic)")
        exit 1
    fi
}

function pipelineIDToName()
{
	if [[ $# -ne 1 ]]
	then 
	   (>&2 echo "[ERROR] DAmar.cfg: pipelineIDToName() invalid number of arguments: $# Expected 1! ");
   		exit 1
 	fi 
 	
 	if ! $(isNumber $1)
	then
		(>&2 echo "[ERROR] DAmar.cfg: pipelineIDToName(): Argument $1 must be a positive number!!")
		exit 1
	fi
 	
 	if [[ $1 -eq 0 ]]
    then
        echo -n "init"
	elif [[ $1 -eq 1 ]]
    then
        echo -n "mito"
	elif [[ $1 -eq 2 ]]
    then
        echo -n "cover"
    elif [[ $1 -eq 3 ]]
    then
        echo -n "rmask"
    elif [[ $1 -eq 4 ]]
    then
        echo -n "fix"
    elif [[ $1 -eq 5 ]]
    then
        echo -n "fmask"
	elif [[ $1 -eq 6 ]]
    then
        echo -n "scrub"
	elif [[ $1 -eq 6 ]]
    then
        echo -n "filt"
    elif [[ $1 -eq 8 ]]
    then
        echo -n "tour"
	elif [[ $1 -eq 9 ]]
    then
        echo -n "corr"
    elif [[ $1 -eq 10 ]]
    then
        echo -n "cont"
    elif [[ $1 -eq 11 ]]
    then
        echo -n "arrow"
    elif [[ $1 -eq 12 ]]
    then
        echo -n "pDups"
    elif [[ $1 -eq 13 ]]
    then
        echo -n "freebayes"
    elif [[ $1 -eq 14 ]]
    then
        echo -n "phase"
    elif [[ $1 -eq 15 ]]
    then
        echo -n "s10x"
    elif [[ $1 -eq 16 ]]
    then
        echo -n "sbionano" 
    elif [[ $1 -eq 17 ]]
    then
        echo -n "shic"
    else
        (>&2 echo "[ERROR] DAmar_slurm: unknown phase ${currentPhase}! Supported values (0-17)")
        exit 1
    fi
}

function getPipelineDir()
{
	if [[ $# -ne 1 ]]
	then 
	   (>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() invalid number of arguments: $# Expected 1! ");
   		exit 1
 	fi 
 	
 	if ! $(isNumber $1)
 	then
 	 	(>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() invalid argument: $1! Must be a positive number!");
   		exit 1
 	fi

	if [[ $1 -eq 0 ]]
	then
		if [[ -z "${INIT_DIR}" ]]
		then 
    		(>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() You have to set variable INIT_DIR")
    		exit 1
		fi 
	
		echo -n "${INIT_DIR}"
	elif [[ $1 -eq 1 ]]
	then
		if [[ -z "${MITO_DIR}" ]]
		then 
    		(>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() You have to set variable MITO_DIR")
    		exit 1
		fi 
	
		echo -n "${MITO_DIR}"
	elif [[ $1 -gt 2 && $1 -lt 5 ]]
	then
		if [[ -z "${PATCHING_DIR}" ]]
		then 
    		(>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() You have to set variable PATCHING_DIR")
    		exit 1
		fi 
	
		echo -n "${PATCHING_DIR}"
	elif [[ $1 -gt 2 && $1 -lt 5 ]]
	then
		if [[ -z "${PATCHING_DIR}" ]]
		then 
    		(>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() You have to set variable PATCHING_DIR")
    		exit 1
		fi 
	
		echo -n "${PATCHING_DIR}"
	elif [[ $1 -gt 2 && $1 -lt 5 ]]
	then
		if [[ -z "${ASSMEBLY_DIR}" ]]
		then 
		    (>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() You have to set variable ASSMEBLY_DIR")
		    exit 1
		fi
	
		if [[ "${ASSMEBLY_DIR}" == "${PATCHING_DIR}" ]]
		then 
		    (>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() PATCHING_DIR must be different from ASSMEBLY_DIR")
		    exit 1
		fi
	
		if [[ -z "${FIX_REPMASK_USELAFIX_PATH}" ]]
		then 
			(>&2 echo "[WARNING] DAmar.cfg: getPipelineDir() Variable FIX_REPMASK_USELAFIX_PATH is not set.Try to use default path: patchedReads_dalign")
			FIX_REPMASK_USELAFIX_PATH="patchedReads_dalign"
		fi
		
		echo -n "${ASSMEBLY_DIR}_${FIX_REPMASK_USELAFIX_PATH}"		
	else
		 (>&2 echo "[ERROR] DAmar.cfg: getPipelineDir() DAmar pipeline $1 is not yet supported!")
		  exit 1
	fi
}


function ensureAndEnterPipelineDir()
{
	if [[ $# -ne 1 ]]
	then 
	   (>&2 echo "[ERROR] DAmar.cfg: ensureAndEnterPipelineDir() invalid number of arguments: $# Expected 1! ");
   		exit 1
 	fi 
 	
 	d=$(getPipelineDir $1)
 	mkdir -p ${d}
	cd ${d}
}

function getNextPipelineStep()
{
	if [[ $# -ne 2 ]]
	then 
	   (>&2 echo "[ERROR] DAmar.cfg: getNextPipelineStep() invalid number of arguments: $# Expect 2 arguments pipelineIdx and pipelineStepId}! ");
   		exit 1
 	fi 
 	
 	local pipelineIdx=$1	
 	local pipelineStepId=$2

	nextStep=$((pipelineStepId+1))
	
	if [[ ${nextStep} -le ${RUN_DAMAR[$((pipelineIdx+3))]} ]] 
	then
		echo -n "${nextStep}"
	else
		echo -n "-1"
	fi	
}

function getNextPipelineIndex()
{
	if [[ $# -ne 2 ]]
	then 
	   (>&2 echo "[ERROR] DAmar.cfg: getNextPipelineIndex() invalid number of arguments: $# Expect 2 arguments pipelineIdx and pipelineID}! ");
   		exit 1
 	fi 
 	
 	local pipelineIdx=$1	
 	local pipelineID=$2
 	
 	nextPipelineIdx=$((pipelineIdx+5))
 	while [[ ${nextPipelineIdx} -lt ${#RUN_DAMAR[@]} ]]
 	do
 		if [[ ${RUN_DAMAR[$((nextPipelineIdx+4))]} -eq ${pipelineID} ]] 
 		then
 			echo -n "${nextPipelineIdx}"
 			break	
 		fi 
 	done 

	if [[ ${pipelineIdx} -ge ${#RUN_DAMAR[@]} ]]
	then
		echo -n "-1"
	fi 
}

function getJobPara()
{
	if [[ $# -ne 3 ]]
	then 
	   (>&2 echo "[ERROR] DAmar.cfg: getJobPara() invalid number of arguments: $# Expect 3 arguments pipelineName jobName jobArgument}! ");
   		exit 1
 	fi 
 	
	local result=""
 	local TMP="${2}JobPara"
	if [[ -z "${!TMP}" ]]
	then
		echo -n "${result}"
	else
		x=0
		end=$(eval echo \${#$(echo ${TMP})[@]})
	
		if [[ $((end % 3)) -ne 0 ]]
		then 
			(>&2 echo "[ERROR] DAmar.cfg: getJobPara() Variable ${TMP} has invalid number of arguments: ${end}! Must be multiple of triples ");
   			exit 1
		fi
	
		while [[ ${x} -lt ${end} ]]
		do 
			y=$((x+1))
			z=$((x+2))
			
			## todo add special solution if $2 == mask
			
			if [[ $(eval echo \${$(echo ${TMP})[${x:-@}]}) == "$1" && $(eval echo \${$(echo ${TMP})[${y:-@}]}) == "${3}" ]]
			then
				if [[ -z ${result} ]]
				then
					result=$(eval echo \${$(echo ${TMP})[${z:-@}]})
				else
					result="${result} $(eval echo \${$(echo ${TMP})[${z:-@}]})"
				fi
			fi
			x=$((x+3))
		done
		
		echo -n ${result}
	fi 	
}

function setDabaseName()
{
	if [[ -n ${PACBIO_TYPE} ]] 
	then 
		if [[ "${PACBIO_TYPE}" == "LoFi" ]]
		then
			# check if DB's are available 
	        if [[ ! ../${INIT_DIR}/pacbio/lofi/db/run/${PROJECT_ID}_M_LoFi.db ]]
	        then 
	    		(>&2 echo "[ERROR] DAmar.cfg: Could not find database: ../${INIT_DIR}/pacbio/lofi/db/run/${PROJECT_ID}_M_LoFi.db! Run init first!!!");
	   			exit 1        	
	    	fi
	    	
	    	if [[ ! ../${INIT_DIR}/pacbio/lofi/db/run/${PROJECT_ID}_Z_LoFi.db ]]
	        then 
	    		(>&2 echo "[ERROR] DAmar.cfg: Could not find database: ../${INIT_DIR}/pacbio/lofi/db/run/${PROJECT_ID}_Z_LoFi.db! Run init first!!!");
	   			exit 1        	
	    	fi
			
			DB_Z=${PROJECT_ID}_Z_LoFi
			DB_M=${PROJECT_ID}_M_LoFi
			nblocks=$(getNumOfDbBlocks ../${INIT_DIR}/pacbio/lofi/db/run/${PROJECT_ID}_M_LoFi.db)			
		elif [[ "${PACBIO_TYPE}" == "HiFi" ]]
		then
			# check if DB's are available 
	    	if [[ ! ../${INIT_DIR}/pacbio/hifi/db/run/${PROJECT_ID}_M_HiFi.db ]]
	        then 
	    		(>&2 echo "[ERROR] DAmar.cfg: Could not find database: ../${INIT_DIR}/pacbio/hifi/db/run/${PROJECT_ID}_M_HiFi.db! Run init first!!!");
	   			exit 1        	
	    	fi
	    	
	    	if [[ ! ../${INIT_DIR}/pacbio/hifi/db/run/${PROJECT_ID}_Z_HiFi.db ]]
	        then 
	    		(>&2 echo "[ERROR] DAmar.cfg: Could not find database: ../${INIT_DIR}/pacbio/hifi/db/run/${PROJECT_ID}_Z_HiFi.db! Run init first!!!");
	   			exit 1        	
	    	fi
			
			DB_Z=${PROJECT_ID}_Z_HiFi
			DB_M=${PROJECT_ID}_M_HiFi
			nblocks=$(getNumOfDbBlocks ../${INIT_DIR}/pacbio/hifi/db/run/${PROJECT_ID}_M_HiFi.db)
		else
			(>&2 echo "[ERROR] DAmar.cfg: PACBIO_TYPE: ${PACBIO_TYPE} is unknwon! Must be set to either LoFi or HiFi!");
	   		exit 1
		fi
	else
		(>&2 echo "[ERROR] DAmar.cfg: Variable PACBIO_TYPE must be set to either LoFi or HiFi!");
	   	exit 1
	fi	
}

function setDalignerOptions()
{
	numRepTracks=$1
	
	### find and set daligner options 
    getSlurmRunParameter ${pipelineStepName}
    
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} daligner partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} daligner threads)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[1]=${para}			
	fi
	para=$(getJobPara ${pipelineName} daligner mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	### available options: verbose identity kmer err minLen	mem	hits trace mask
	DALIGNER_OPT=""
	
	para=$(getJobPara ${pipelineName} daligner verbose)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DALIGNER_OPT="${DALIGNER_OPT} -v"	
	fi
    para=$(getJobPara ${pipelineName} daligner identity)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DALIGNER_OPT="${DALIGNER_OPT} -I"	
	fi
	para=$(getJobPara ${pipelineName} daligner kmer)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DALIGNER_OPT="${DALIGNER_OPT} -k${para}"	
	fi
    para=$(getJobPara ${pipelineName} daligner err)
	if $(isFloatNumber ${para})
	then 
		DALIGNER_OPT="${DALIGNER_OPT} -e${para}"	
	fi
	para=$(getJobPara ${pipelineName} daligner minLen)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DALIGNER_OPT="${DALIGNER_OPT} -l${para}"	
	fi
	para=$(getJobPara ${pipelineName} daligner mem)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DALIGNER_OPT="${DALIGNER_OPT} -M$((${para}/1024))"				
	fi
	para=$(getJobPara ${pipelineName} daligner hits)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DALIGNER_OPT="${DALIGNER_OPT} -h${para}"				
	fi
	para=$(getJobPara ${pipelineName} daligner trace)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DALIGNER_OPT="${DALIGNER_OPT} -t${para}"				
	fi
	para=$(getJobPara ${pipelineName} daligner threads)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DALIGNER_OPT="${DALIGNER_OPT} -T${para}"					
	fi

	### set some meta variables 
	para=$(getJobPara ${pipelineName} daligner asymmetric)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DALIGNER_ASYMMETRIC=1
	else
		DALIGNER_ASYMMETRIC=0					
	fi

	para=$(getJobPara ${pipelineName} daligner blockComps)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DALIGNER_BLOCKCMP=${para}
	else
		DALIGNER_BLOCKCMP=8					
	fi
	
	para=$(getJobPara ${pipelineName} daligner mask)
	pName=${pipelineName}
	if [[ "${pipelineName}" == "fix" ]] 
	then
		pName=rmask
	elif [[ "${pipelineName}" == "scrub" ]] 
	then
		pName=fmask
	fi

	for x in ${para}
	do
		if [[ "$x" == "LArepeatJobPara" ]]; 
		then						
			blocks_cov=($(getJobPara ${pName} LArepeat blocks_cov))
			local to=${numRepTracks}
			if [[ ${to} -lt 0 ]]
			then 
				to=${#blocks_cov[@]}
			fi 
			
			for y in $(seq 1 ${to})
			do
				m=rep_B$(echo ${blocks_cov[$((y-1))]} | sed -e "s:_:C:")
				DALIGNER_OPT="${DALIGNER_OPT} -m${m}"				
			done
		else
			DALIGNER_OPT="${DALIGNER_OPT} -m${x}"
		fi
	done	
	
	para=$(getJobPara ${pName} LArepeat blocks_cov)
	local c=0
	for x in ${para}
	do
		REPEAT_BLOCKCMP[$c]=$(echo ${x} | awk -F _ '{print $1}')
		REPEAT_COV[$c]=$(echo ${x} | awk -F _ '{print $2}')
		c=$((c+1))
	done	 
}

function setLAmergeOptions()
{
	### find and set daligner options 
    getSlurmRunParameter ${pipelineStepName}
    
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} LAmerge partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} LAmerge threads)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[1]=${para}			
	fi
	para=$(getJobPara ${pipelineName} LAmerge mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	### available options: verbose identity kmer err minLen	mem	hits trace mask
	LAMERGE_OPT=""

	para=$(getJobPara ${pipelineName} LAmerge nfiles)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		LAMERGE_OPT="${LAMERGE_OPT} -n${para}"
	else
		LAMERGE_OPT="${LAMERGE_OPT} -n196"
	fi

	para=$(getJobPara ${pipelineName} LAmerge verbose)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		for i in $(seq 1 ${para})
		do 
			LAMERGE_OPT="${LAMERGE_OPT} -v"
		done		
	fi

	para=$(getJobPara ${pipelineName} LAmerge keepIntermediates)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		LAMERGE_OPT="${LAMERGE_OPT} -k"
	fi

	para=$(getJobPara ${pipelineName} LAmerge suffix)
	if [[ -n ${para} ]]
	then 
		LAMERGE_OPT="${LAMERGE_OPT} -S${para}"
	fi

	para=$(getJobPara ${pipelineName} LAmerge fofn)
	if [[ -n ${para} ]]
	then 
		LAMERGE_OPT="${LAMERGE_OPT} -f${para}"
	fi

	para=$(getJobPara ${pipelineName} LAmerge sort)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		LAMERGE_OPT="${LAMERGE_OPT} -s"
	fi
}

# arguments pipelineName(e.g. fix,rmask,fmask,...) repeatIdx(-1,0,1,2.....)  
function setLArepeatOptions()
{
	local pName=$1
    local idx=$2
        
    ### find and set daligner options 
    getSlurmRunParameter ${pipelineStepName}
    
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pName} LArepeat partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pName} LArepeat threads)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[1]=${para}			
	fi
	para=$(getJobPara ${pName} LArepeat mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	### available options: hghCov lowCov minLen identity blocks_cov maxCov
	LAREPEAT_OPT=""
	REPEAT_BLOCKCMP=()
	REPEAT_COV=()
	REPEAT_LOWCOV=()
	REPEAT_HGHCOV=()
	REPEAT_TRACK=()
	
	para=$(getJobPara ${pName} LArepeat hghCov)
	c=0
	for x in ${para}
	do
		if $(isFloatNumber ${x})
		then 
			REPEAT_HGHCOV[$c]=${x}
			c=$((c+1))
		fi
	done
	para=$(getJobPara ${pName} LArepeat lowCov)
	c=0
	for x in ${para}
	do
		if $(isFloatNumber ${x})
		then 
			REPEAT_LOWCOV[$c]=${x}
			c=$((c+1))
		fi
	done
	para=$(getJobPara ${pName} LArepeat minLen)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		LAREPEAT_OPT="${LAREPEAT_OPT} -o${para}"	
	fi
	para=$(getJobPara ${pName} LArepeat identity)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		LAREPEAT_OPT="${LAREPEAT_OPT} -I"	
	fi

	para=$(getJobPara ${pName} LArepeat blocks_cov)
	c=0
	for x in ${para}
	do
		REPEAT_BLOCKCMP[$c]=$(echo ${x} | awk -F _ '{print $1}')
		REPEAT_COV[$c]=$(echo ${x} | awk -F _ '{print $2}')
		REPEAT_TRACK[$c]=rep_B${REPEAT_BLOCKCMP[${c}]}C${REPEAT_COV[${c}]}
		if [[ ${c} -eq ${idx} ]]
		then
			LAREPEAT_OPT="${LAREPEAT_OPT} -c${REPEAT_COV[$c]}"			
			LAREPEAT_OPT="${LAREPEAT_OPT} -t${REPEAT_TRACK[$c]} -l1.0 -h1.0"			
		fi		
		c=$((c+1))
	done

	para=$(getJobPara ${pName} LArepeat cov)
	if [[ ${c} -eq 0 ]]
	then 
		for x in ${para}
		do
			if $(isNumber ${x}) && [ ${x} -gt 0 ]
			then 
				REPEAT_COV[$c]=${x}
				local T=""

				if [[ ${c} -eq ${idx} ]]
				then
					LAREPEAT_OPT="${LAREPEAT_OPT} -c${REPEAT_COV[$c]}"
				fi
			
				T=rep_c${REPEAT_COV[$c]}
				if [[ ${#REPEAT_LOWCOV[@]} -gt ${c} ]]
				then 
					T="${T}_l${REPEAT_LOWCOV[${c}]}"
					if [[ ${c} -eq ${idx} ]]
					then
						LAREPEAT_OPT="${LAREPEAT_OPT} -l${REPEAT_LOWCOV[${c}]}"
					fi
				else # set default value
					T="${T}_l1.7"
					if [[ ${c} -eq ${idx} ]]
					then
						LAREPEAT_OPT="${LAREPEAT_OPT} -l1.7"
					fi
				fi

				if [[ ${#REPEAT_HGHCOV[@]} -gt ${c} ]]
				then 
					T="${T}_h${REPEAT_HGHCOV[${c}]}"
					if [[ ${c} -eq ${idx} ]]
					then
						LAREPEAT_OPT="${LAREPEAT_OPT} -h${REPEAT_HGHCOV[${c}]}"
					fi
				else # set default value
					T="${T}_l1.5"
					if [[ ${c} -eq ${idx} ]]
					then
						LAREPEAT_OPT="${LAREPEAT_OPT} -h1.5"
					fi
				fi
				
				T="${T}_pType${pipelineType}"
				if [[ ${c} -eq ${idx} ]]
				then
					LAREPEAT_OPT="${LAREPEAT_OPT} -t${T}"
				fi			
				
				REPEAT_TRACK[$c]=${T}
				c=$((c+1))
			elif [[ "${x}" == -1 ]]
			then
				REPEAT_COV[$c]=${x}
				if [[ ${c} -eq ${idx} ]]
				then
					LAREPEAT_OPT="${LAREPEAT_OPT} -c${x}"
				fi
			
				local T=rep_calCov
				
				if [[ ${#REPEAT_LOWCOV[@]} -gt ${c} ]]
				then 
					T="${T}_l${REPEAT_LOWCOV[${c}]}"
					if [[ ${c} -eq ${idx} ]]
					then
						LAREPEAT_OPT="${LAREPEAT_OPT} -l${REPEAT_LOWCOV[${c}]}"
					fi
				else # set default value
					T="${T}_l1.7"
					if [[ ${c} -eq ${idx} ]]
					then
						LAREPEAT_OPT="${LAREPEAT_OPT} -l1.7"
					fi
				fi

				if [[ ${#REPEAT_HGHCOV[@]} -gt ${c} ]]
				then 
					T="${T}_h${REPEAT_HGHCOV[${c}]}"
					if [[ ${c} -eq ${idx} ]]
					then
						LAREPEAT_OPT="${LAREPEAT_OPT} -h${REPEAT_HGHCOV[${c}]}"
					fi
				else # set default value
					T="${T}_l1.5"
					if [[ ${c} -eq ${idx} ]]
				  	then
						LAREPEAT_OPT="${LAREPEAT_OPT} -h1.5"
					fi
				fi
				T="${T}_pType${pipelineType}"
				if [[ ${c} -eq ${idx} ]]
				then						 
					LAREPEAT_OPT="${LAREPEAT_OPT} -t${T}"
				fi
			
				REPEAT_TRACK[$c]=${T}
				c=$((c+1))
			else
				(>&2 echo "[ERROR] DAmar.cfg: setLArepeatOptions(): Could not detect valid coverage value for LArepeat! Found \"${x}\"! Allowed values -1 or any positive number (not 0)!");
				exit 1					
			fi
		done 	
	fi

	if [[ ${c} -eq 0 ]]
	then
		(>&2 echo "[ERROR] DAmar.cfg: setLArepeatOptions(): Could not detect any valid coverage valuee for LArepeat! You have to either set blocks_cov (e.g. in masking pipeline) or cov!");
   		exit 1
	fi 
	
	para=$(getJobPara ${pName} LArepeat maxCov)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		LAREPEAT_OPT="${LAREPEAT_OPT} -M${para}"
	fi
}

function setREPmaskOptions() 
{
	local pName=$1
    local idx=$2
    
    ## set variable REPEAT_BLOCKCMP and REPEAT_COV via setLArepeatOptions 
	setLArepeatOptions ${pName} ${idx} 
    
    ### find and set daligner options 
    getSlurmRunParameter ${pipelineStepName}
    
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pName} REPmask partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pName} REPmask threads)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[1]=${para}			
	fi
	para=$(getJobPara ${pName} REPmask mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	### available options: verbose repCov
	REPMASK_OPT=""
	
	para=$(getJobPara ${pName} REPmask verbose)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		REPMASK_OPT="${REPMASK_OPT} -v"					
	fi
	para=$(getJobPara ${pName} REPmask repCov)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		REPMASK_OPT="${REPMASK_OPT} -c${para}"
	else 
		(>&2 echo "[WARNING] DAmarRawMaskPipeline - No repeat coverage threshold could be found! Please set array REPmaskJobPara+=(rmask repCov <YourRepeatCoverage>) appropriately!")
		exit 1
	fi
	
	REPMASK_OPT="${REPMASK_OPT} -n${REPEAT_TRACK[${idx}]}"
}

function setTKmergeOptions() 
{
    ### find and set daligner options 
    getSlurmRunParameter ${pipelineStepName}
    
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} TKmerge partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} TKmerge threads)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[1]=${para}			
	fi
	para=$(getJobPara ${pipelineName} TKmerge mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	### available options: delInputTracks
	TKMERGE_OPT=""
	
	para=$(getJobPara ${pipelineName} TKmerge delInputTracks)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		TKMERGE_OPT="${TKMERGE_OPT} -d"	
	fi
}

function setTKcombineOptions() 
{
    delete=$1
    
	### find and set daligner options 
    getSlurmRunParameter ${pipelineStepName}
    
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} TKcombine partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} TKcombine threads)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[1]=${para}			
	fi
	para=$(getJobPara ${pipelineName} TKcombine mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	TKCOMBINE_OPT=""
	### available options: verbose delInputTracks
	
	para=$(getJobPara ${pipelineName} TKcombine verbose)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		TKCOMBINE_OPT="${TKCOMBINE_OPT} -v"	
	fi

	para=$(getJobPara ${pipelineName} TKcombine delInputTracks)
	if $(isNumber ${para}) && [ ${para} -gt 0 ] && [ ${ignoreDelete} != 0 ]
	then 
		TKCOMBINE_OPT="${TKCOMBINE_OPT} -d"	
	fi
}

function setLAqOptions()
{
	### find and set LAq options 
    getSlurmRunParameter ${pipelineStepName}
    
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} LAq partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} LAq threads)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[1]=${para}			
	fi
	para=$(getJobPara ${pipelineName} LAq mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	LAQ_OPT=""
	### available options: minSeg qCutoff
	
	LAQ_MINSEG=$(getJobPara ${pipelineName} LAq minSeg)
	if $(isNumber ${LAQ_MINSEG}) && [ ${LAQ_MINSEG} -gt 0 ]
	then 
		LAQ_OPT="${LAQ_OPT} -s${LAQ_MINSEG}"
	else
		LAQ_MINSEG=2
		LAQ_OPT="${LAQ_OPT} -s${LAQ_MINSEG}"	
	fi

	LAQ_QCUTOFF=$(getJobPara ${pipelineName} LAq qCutoff)
	if ! $(isNumber ${LAQ_QCUTOFF})
	then 
		LAQ_QCUTOFF=25
	fi
		
	local tspace=$(getJobPara ${pipelineName} daligner trace)
	if $(isNumber ${tspace}) && [ ${tspace} -ne 100 ]
	then
		LAQ_QCUTOFF=$((LAQ_QCUTOFF*trace/100+1))
	fi

	LAQ_OPT="${LAQ_OPT} -s${LAQ_MINSEG} -d${LAQ_QCUTOFF}"
}

function setLAfixOptions()
{
	setLAqOptions
	
	### find and set LAfix options 
    getSlurmRunParameter ${pipelineStepName}
    
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} LAfix partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} LAfix threads)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[1]=${para}			
	fi
	para=$(getJobPara ${pipelineName} LAfix mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	LAFIX_OPT=""
	### available options: maxGap minRLen lowCov borderCov maxChimerLen aggChimerDet discardChimers fixChimers convertTrack repeat trimFilePrefix
	
	para=$(getJobPara ${pipelineName} LAfix maxGap)
	if $(isNumber ${para}) || [[ "${para}" == "-1" ]]
	then 
		LAFIX_OPT="${LAFIX_OPT} -g${para}"
	fi

	para=$(getJobPara ${pipelineName} LAfix minRLen)
	if $(isNumber ${para}) && [[ ${para} -gt 0 ]]
	then 
		LAFIX_OPT="${LAFIX_OPT} -x${para}"
	fi

	para=$(getJobPara ${pipelineName} LAfix lowCov)
	if $(isNumber ${para}) && [[ ${para} -gt 0 ]]
	then 
		LAFIX_OPT="${LAFIX_OPT} -l"
	fi

	para=$(getJobPara ${pipelineName} LAfix borderCov)
	if $(isNumber ${para}) && [[ ${para} -gt 0 ]]
	then 
		LAFIX_OPT="${LAFIX_OPT} -b${para}"
	fi

	para=$(getJobPara ${pipelineName} LAfix maxChimerLen)
	if $(isNumber ${para}) && [[ ${para} -gt 0 ]]
	then 
		LAFIX_OPT="${LAFIX_OPT} -C${para}"
	fi

	para=$(getJobPara ${pipelineName} LAfix aggChimerDet)
	if $(isNumber ${para}) && [[ ${para} -gt 0 ]]
	then 
		LAFIX_OPT="${LAFIX_OPT} -a"
	fi

	para=$(getJobPara ${pipelineName} LAfix discardChimers)
	if $(isNumber ${para}) && [[ ${para} -gt 0 ]]
	then 
		LAFIX_OPT="${LAFIX_OPT} -d"
	fi
	
	para=$(getJobPara ${pipelineName} LAfix fixChimers)
	if $(isNumber ${para}) && [[ ${para} -gt 0 ]]
	then 
		LAFIX_OPT="${LAFIX_OPT} -X"
	fi

	para=$(getJobPara ${pipelineName} LAfix convertTrack)
	for x in ${para}
	do
		if [[ -n ${x} ]]
		then 
			LAFIX_OPT="${LAFIX_OPT} -c${x}"
		fi	
	done

	para=$(getJobPara ${pipelineName} LAfix trimFilePrefix)
	if [[ -n ${para} ]]
	then 
		LAFIX_TRIMFILE="${para}"
	fi

	para=$(getJobPara ${pipelineName} LAfix repeat)
	if $(isNumber ${para})
	then 
		LAFIX_OPT="${LAFIX_OPT} -rcombinedRep${para}_pType${pipelineType}_tan_dust"
	fi
    
    LAFIX_OPT="${LAFIX_OPT} -q q0_d${LAQ_QCUTOFF}_s${LAQ_MINSEG}_pType${pipelineType}"
	LAFIX_OPT="${LAFIX_OPT} -t trim0_d${LAQ_QCUTOFF}_s${LAQ_MINSEG}_pType${pipelineType}"       
}

function setLAseparateOptions()
{
	type=$1 ## either 0 for repcomp or 1 for forcealign 
	pType=$2 # select other pipelineType if required
	
	if [[ "${type}" != 0 && ${type} != 1 ]]
	then 
		(>&2 echo "[ERROR] DAmar.cfg: setLAseparateOptions(): LAseparate type must be passed as arguemt - [0|1]!");
   		exit 1	
	fi
	
	### find and set LAseparate options 
    getSlurmRunParameter ${pipelineStepName}
    
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} LAseparate partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} LAseparate threads)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[1]=${para}			
	fi
	para=$(getJobPara ${pipelineName} LAseparate mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	LASEPARATE_OPT=""
	### available options: oLen rLen repeat twoPass
	
	para=$(getJobPara ${pipelineName} LAseparate oLen)
	if $(isNumber ${para}) && [[ ${para} -gt 0 ]]
	then 
		LASEPARATE_OPT="${LASEPARATE_OPT} -o${para}"
	fi
	
	para=$(getJobPara ${pipelineName} LAseparate rLen)
	if $(isNumber ${para}) && [[ ${para} -gt 0 ]]
	then 
		LASEPARATE_OPT="${LASEPARATE_OPT} -r${para}"
	fi

	para=$(getJobPara ${pipelineName} LAseparate twoPass)
	if $(isNumber ${para}) && [[ ${para} -gt 0 ]]
	then 
		LASEPARATE_OPT="${LASEPARATE_OPT} -L"
	fi

	para=$(getJobPara ${pipelineName} LAseparate repeat)
	if $(isNumber ${para}) && [[ ${para} -gt 0 ]]
	then 
		LASEPARATE_OPT="${LASEPARATE_OPT} -rcombinedRep_pType${pType}_tan_dust"
	fi

	LASEPARATE_OPT="${LASEPARATE_OPT} -T${type}"
}

function setRepcompOptions()
{
	### find and set repcomp options 
    getSlurmRunParameter ${pipelineStepName}
    
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} repcomp partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	
	REPCOMP_OPT=""
	### available options: tspace inBlocksize kmer mem threads eCor mask oLen
	
	para=$(getJobPara ${pipelineName} repcomp tspace)
	if $(isNumber ${para}) && [[ ${para} -gt 0 ]]
	then 
		REPCOMP_OPT="${REPCOMP_OPT} --tspace${para}"
	fi

	para=$(getJobPara ${pipelineName} repcomp inBlocksize)
	if $(isNumber ${para}) && [[ ${para} -gt 0 ]]
	then 
		REPCOMP_OPT="${REPCOMP_OPT} -i${para}"
	fi
	
	para=$(getJobPara ${pipelineName} repcomp kmer)
	if $(isNumber ${para}) && [[ ${para} -gt 0 ]]
	then 
		REPCOMP_OPT="${REPCOMP_OPT} -k${para}"
	fi

	para=$(getJobPara ${pipelineName} repcomp mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}	
		REPCOMP_OPT="${REPCOMP_OPT} -M${para}"			
	fi

	para=$(getJobPara ${pipelineName} repcomp threads)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[1]=${para}
		REPCOMP_OPT="${REPCOMP_OPT} -t${para}"					
	fi

	para=$(getJobPara ${pipelineName} repcomp eCor)
	if $(isNumber ${para}) && [[ ${para} -gt 0 ]]
	then 
		REPCOMP_OPT="${REPCOMP_OPT} -e${para}"
	fi

	para=$(getJobPara ${pipelineName} repcomp mask)
	for i in ${para}
	do
		REPCOMP_OPT="${REPCOMP_OPT} -m${i}"
	done

	para=$(getJobPara ${pipelineName} repcomp oLen)
	if $(isNumber ${para}) && [[ ${para} -gt 0 ]]
	then 
		REPCOMP_OPT="${REPCOMP_OPT} -l${para}"
	fi
}

function setDBdustOptions()
{
	### available options: window threshold minLen bias
	DBDUST_OPT=""
	
	para=$(getJobPara ${pipelineName} DBdust window)
	if [[ "x${para}" != "x" && $(isNumber ${para}) ]]
	then 
		DBDUST_OPT="${DBDUST_OPT} -w${para}"	
	fi
	
	para=$(getJobPara ${pipelineName} DBdust threshold)
	if [[ "x${para}" != "x" && $(isFloatNumber ${para}) ]]
	then 
		DBDUST_OPT="${DBDUST_OPT} -t${para}"	
	fi
	
	para=$(getJobPara ${pipelineName} DBdust minLen)
	if [[ "x${para}" != "x" && $(isNumber ${para}) ]]
	then 
		DBDUST_OPT="${DBDUST_OPT} -t${para}"	
	fi
	
	para=$(getJobPara ${pipelineName} DBdust bias)
	if [[ "x${para}" != "x" && $(isNumber ${para}) && ${para} -gt 0 ]]
	then 
		DBDUST_OPT="${DBDUST_OPT} -b"	
	fi
}

function setCatrackOptions()
{
	## this sets the global array variable SLURM_RUN_PARA (partition, nCores, mem, time, step, tasks)
	getSlurmRunParameter ${pipelineStepName}
	
	### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} Catrack partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} Catrack mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	
	### available options: verbose delete force
	CATRACK_OPT=""
	
	para=$(getJobPara ${pipelineName} Catrack verbose)
	if [[ "x${para}" != "x" && $(isNumber ${para}) && ${para} -gt 0 ]]
	then 
		CATRACK_OPT="${CATRACK_OPT} -v"	
	fi
	
	para=$(getJobPara ${pipelineName} Catrack delete)
	if [[ "x${para}" != "x" && $(isNumber ${para}) && ${para} -gt 0 ]]
	then 
		CATRACK_OPT="${CATRACK_OPT} -d"	
	fi
	
	para=$(getJobPara ${pipelineName} Catrack force)
	if [[ "x${para}" != "x" && $(isNumber ${para}) && ${para} -gt 0 ]]
	then 
		CATRACK_OPT="${CATRACK_OPT} -f"	
	fi
}

function setDatanderOptions()
{
	## this sets the global array variable SLURM_RUN_PARA (partition, nCores, mem, time, step, tasks)
	getSlurmRunParameter ${pipelineStepName}
	
	### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} datander partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} datander mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	### available options: verbose kmer window hits threads tmpDir err minLen trace
	DATANDER_OPT=""
	
	para=$(getJobPara ${pipelineName} datander verbose)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DATANDER_OPT="${DATANDER_OPT} -v"	
	fi
	
	para=$(getJobPara ${pipelineName} datander kmer)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DATANDER_OPT="${DATANDER_OPT} -k${para}"	
	fi
	
	para=$(getJobPara ${pipelineName} datander window)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DATANDER_OPT="${DATANDER_OPT} -w${para}"	
	fi
	
	para=$(getJobPara ${pipelineName} datander hits)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DATANDER_OPT="${DATANDER_OPT} -h${para}"	
	fi
	
	para=$(getJobPara ${pipelineName} datander threads)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DATANDER_OPT="${DATANDER_OPT} -T${para}"	
		SLURM_RUN_PARA[1]=${para}
	fi
	
	para=$(getJobPara ${pipelineName} datander err)
	if $(isFloatNumber ${para})
	then 
		DATANDER_OPT="${DATANDER_OPT} -e${para}"	
	fi
	
	para=$(getJobPara ${pipelineName} datander tmpDir)
	if [[ "x${para}" != "x" ]]
	then 
		DATANDER_OPT="${DATANDER_OPT} -P${para}"	
	fi
	
	para=$(getJobPara ${pipelineName} datander minLen)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DATANDER_OPT="${DATANDER_OPT} -l${para}"	
	fi
	
	para=$(getJobPara ${pipelineName} datander trace)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DATANDER_OPT="${DATANDER_OPT} -s${para}"	
	fi	
}

function setTANmaskOptions()
{
	## this sets the global array variable SLURM_RUN_PARA (partition, nCores, mem, time, step, tasks)
	getSlurmRunParameter ${pipelineStepName}
	   	        
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} TANmask partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} TANmask mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	### available options: verbose minLen 
	TANMASK_OPT=""
	
	para=$(getJobPara ${pipelineName} TANmask verbose)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		TANMASK_OPT="${TANMASK_OPT} -v"	
	fi
	para=$(getJobPara ${pipelineName} TANmask minLen)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		TANMASK_OPT="${TANMASK_OPT} -n${para}"	
	fi	
}

function setlassortOptions()
{
	## this sets the global array variable SLURM_RUN_PARA (partition, nCores, mem, time, step, tasks)
	getSlurmRunParameter ${pipelineStepName}
	   	        
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} lassort partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} lassort mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	### available options: mergeFan threads sortType 
	LASSORT_OPT=""
	
	para=$(getJobPara ${pipelineName} lassort mergeFan)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		LASSORT_OPT="${LASSORT_OPT} -f${para}"	
	fi

	para=$(getJobPara ${pipelineName} lassort threads)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		LASSORT_OPT="${LASSORT_OPT} -t${para}"
		SLURM_RUN_PARA[1]=${para}
	fi

	para=$(getJobPara ${pipelineName} lassort sortType)
	if [ -n ${para} ]
	then 
		LASSORT_OPT="${LASSORT_OPT} -s${para}"
	fi
}

function setComputeIntrinsicQV2Options()
{
	## this sets the global array variable SLURM_RUN_PARA (partition, nCores, mem, time, step, tasks)
	getSlurmRunParameter ${pipelineStepName}
	   	        
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} computeintrinsicqv2 partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} computeintrinsicqv2 mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	### available options: depth 
	COMPUTEINTRINSICQV_OPT=""

	para=$(getJobPara ${pipelineName} computeintrinsicqv2 depth)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		COMPUTEINTRINSICQV_OPT="${COMPUTEINTRINSICQV_OPT} -d${para}"
	elif $(isNumber ${COV})
	then
		(>&2 echo "[WARNING] DAmar.cfg: setComputeIntrinsicQV2Options(): depth of computeintrincqv2 is not explicitely given - used COV: ${COV} instead!");
		COMPUTEINTRINSICQV_OPT="${COMPUTEINTRINSICQV_OPT} -d${para}"
	else
		(>&2 echo "[WARNING] DAmar.cfg: setComputeIntrinsicQV2Options(): depth of computeintrincqv2 is not found! Set variable computeintrinsicqv2JobPara=(${pipelineName} depth YOURDEPTH) or set variable COV=YOURDEPTH in assembly specific config file!");
		exit 1
	fi		
}

function setLasDetectSimpleRepeatsOptions()
{
	## this sets the global array variable SLURM_RUN_PARA (partition, nCores, mem, time, step, tasks)
	getSlurmRunParameter ${pipelineStepName}
	   	        
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} lasdetectsimplerepeats partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} lasdetectsimplerepeats mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	### available options: erate depth 
	LASDETECTSIMPLEREPEATS_OPT=""

	para=$(getJobPara ${pipelineName} lasdetectsimplerepeats depth)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		LASDETECTSIMPLEREPEATS_OPT="${LASDETECTSIMPLEREPEATS_OPT} -d${para}"
	elif $(isNumber ${COV})
	then
		(>&2 echo "[WARNING] DAmar.cfg: setComputeIntrinsicQV2Options(): depth of computeintrincqv2 is not explicitely given - used COV/2: $((${COV}/2)) instead!");
		LASDETECTSIMPLEREPEATS_OPT="${LASDETECTSIMPLEREPEATS_OPT} -d$(({para}/2))"
	else
		(>&2 echo "[WARNING] DAmar.cfg: setComputeIntrinsicQV2Options(): depth of computeintrincqv2 is not found! Set variable computeintrinsicqv2JobPara=(${pipelineName} depth YOURDEPTH) or set variable COV=YOURDEPTH in assembly specific config file!");
		exit 1
	fi		

	para=$(getJobPara ${pipelineName} lasdetectsimplerepeats erate)
	if $(isFloatNumber ${para}) 
	then 
		LASDETECTSIMPLEREPEATS_OPT="${LASDETECTSIMPLEREPEATS_OPT} -e${para}"
	fi
}

function setLasfilterAlignmentsOptions()
{
	## this sets the global array variable SLURM_RUN_PARA (partition, nCores, mem, time, step, tasks)
	getSlurmRunParameter ${pipelineStepName}
	   	        
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} lasfilteralignments partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} lasfilteralignments mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	### available options: erate
	LASFILTERALIGNMENTS_OPT=""

	para=$(getJobPara ${pipelineName} lasfilteralignments erate)
	if $(isFloatNumber ${para}) 
	then 
		LASFILTERALIGNMENTS_OPT="${LASFILTERALIGNMENTS_OPT} -e${para}"
	fi
}

function setLasfilterAlignmentsBorderRepeatsOptions()
{
	## this sets the global array variable SLURM_RUN_PARA (partition, nCores, mem, time, step, tasks)
	getSlurmRunParameter ${pipelineStepName}
	   	        
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} lasfilteralignmentsborderrepeats partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} lasfilteralignmentsborderrepeats mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	### available options: threads erate
	LASFILTERALIGNMENTSBORDERREPEATS_OPT=""
	
	para=$(getJobPara ${pipelineName} lasfilteralignmentsborderrepeats threads)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		SLURM_RUN_PARA[1]=${para}
		LASFILTERALIGNMENTSBORDERREPEATS_OPT="${LASFILTERALIGNMENTSBORDERREPEATS_OPT} -t${para}"				
	fi

	para=$(getJobPara ${pipelineName} lasfilteralignmentsborderrepeats erate)
	if $(isFloatNumber ${para}) 
	then 
		LASFILTERALIGNMENTSBORDERREPEATS_OPT="${LASFILTERALIGNMENTSBORDERREPEATS_OPT} -e${para}"
	fi
}

function setFilterChainsRawOptions()
{
	## this sets the global array variable SLURM_RUN_PARA (partition, nCores, mem, time, step, tasks)
	getSlurmRunParameter ${pipelineStepName}
	   	        
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} filterchainsraw partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} filterchainsraw mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi
	
	### available options: minLen
	LASFILTERCHAINSRAW_OPT=""
	
	para=$(getJobPara ${pipelineName} filterchainsraw minLen)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		LASFILTERALIGNMENTSBORDERREPEATS_OPT="${LASFILTERALIGNMENTSBORDERREPEATS_OPT} -l${para}"				
	fi	
}

function setLAfilterOptions()
{
	pName=$1
	repeatIdx=$2
	
	## this sets the global array variable SLURM_RUN_PARA (partition, nCores, mem, time, step, tasks)
	getSlurmRunParameter ${pipelineStepName}
	   	        
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} LAfilter partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} LAfilter mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi

	### available options: purge maxSegErr
	LAFILTER_OPT=""
	
	para=$(getJobPara ${pName} LAfilter purge)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		LAFILTER_OPT="${LAFILTER_OPT} -p"				
	fi	

	para=$(getJobPara ${pName} LAfilter purge)
	if $(isFloatNumber ${para})
	then 
		LAFILTER_OPT="${LAFILTER_OPT} -b${para}"				
	fi	
}

function setLAfilterChainsOptions()
{
	pName=$1
	repeatIdx=$2
	
	setLAqOptions
	
	## this sets the global array variable SLURM_RUN_PARA (partition, nCores, mem, time, step, tasks)
	getSlurmRunParameter ${pipelineStepName}
	   	        
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} LAfilter partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} LAfilter mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi

	### available options: anchorBases purge nKeep lowCompTrack trimTrack qTrack unAlnBases diff minLen minRepAReadLen
	LAFILTERCHAINS_OPT=""
	
	para=$(getJobPara ${pName} LAfilterChains anchorBases)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		LAFILTERCHAINS_OPT="${LAFILTERCHAINS_OPT} -n${para}"				
	fi	
	para=$(getJobPara ${pName} LAfilterChains purge)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		LAFILTERCHAINS_OPT="${LAFILTERCHAINS_OPT} -p"				
	fi	
	para=$(getJobPara ${pName} LAfilterChains nKeep)
	if $(isNumber ${para}) && [ ${para} -ge 0 ]
	then 
		LAFILTERCHAINS_OPT="${LAFILTERCHAINS_OPT} -k${para}"				
	fi	
	para=$(getJobPara ${pName} LAfilterChains lowCompTrack)
	if [ "x${para}" != "x" ]
	then 
		LAFILTERCHAINS_OPT="${LAFILTERCHAINS_OPT} -l${para}"				
	fi
	para=$(getJobPara ${pName} LAfilterChains trimTrack)
	if ! [ $(isNumber ${para}) && [ ${para} -ge 0 ] ]
	then 
		para=$(getJobPara ${pName} LAfilterChains qTrack)
	fi
	if $(isNumber ${para}) && [ ${para} -ge 0 ]
	then
		LAFILTERCHAINS_OPT="${LAFILTERCHAINS_OPT} -ttrim0_d${LAQ_QCUTOFF}_s${LAQ_MINSEG}_pType${pipelineType}"
		LAFILTERCHAINS_OPT="${LAFILTERCHAINS_OPT} -qq0_d${LAQ_QCUTOFF}_s${LAQ_MINSEG}_pType${pipelineType}"	
	fi
	para=$(getJobPara ${pName} LAfilterChains unAlnBases)
	if $(isNumber ${para}) && [ ${para} -ge 0 ]
	then 
		LAFILTERCHAINS_OPT="${LAFILTERCHAINS_OPT} -u${para}"				
	fi
	para=$(getJobPara ${pName} LAfilterChains diff)
	if $(isNumber ${para}) && [ ${para} -ge 0 ]
	then 
		LAFILTERCHAINS_OPT="${LAFILTERCHAINS_OPT} -d${para}"				
	fi		
	para=$(getJobPara ${pName} LAfilterChains minLen)
	if $(isNumber ${para}) && [ ${para} -ge 0 ]
	then 
		LAFILTERCHAINS_OPT="${LAFILTERCHAINS_OPT} -o${para}"				
	fi		
	para=$(getJobPara ${pName} LAfilterChains minRepAReadLen)
	if $(isNumber ${para}) && [ ${para} -ge 0 ]
	then 
		LAFILTERCHAINS_OPT="${LAFILTERCHAINS_OPT} -Z${para}"				
	fi			
}

function setDaccordOptions()
{
	## this sets the global array variable SLURM_RUN_PARA (partition, nCores, mem, time, step, tasks)
	getSlurmRunParameter ${pipelineStepName}
	   	        
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} daccord partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} daccord mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi

	### available options: threads window advanceSize maxDepth fullSeq verbose minWindowCov erate minOutLen minKFreq maxKFreq maxOvls vard kmer
	DACCORD_OPT=""
	
	para=$(getJobPara ${pName} daccord threads)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DACCORD_OPT="${DACCORD_OPT} -t${para}"	
		SLURM_RUN_PARA10]=${para}					
	fi	
	para=$(getJobPara ${pName} daccord window)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DACCORD_OPT="${DACCORD_OPT} -w${para}"	
	fi	
	para=$(getJobPara ${pName} daccord advanceSize)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DACCORD_OPT="${DACCORD_OPT} -a${para}"	
	fi
	para=$(getJobPara ${pName} daccord maxDepth)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DACCORD_OPT="${DACCORD_OPT} -d${para}"	
	fi
	para=$(getJobPara ${pName} daccord fullSeq)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DACCORD_OPT="${DACCORD_OPT} -f1"	
	fi
	para=$(getJobPara ${pName} daccord verbose)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DACCORD_OPT="${DACCORD_OPT} -V"	
	fi
	para=$(getJobPara ${pName} daccord minWindowCov)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DACCORD_OPT="${DACCORD_OPT} -m${para}"	
	fi
	para=$(getJobPara ${pName} daccord erate)
	if $(isFloatNumber ${para}) 
	then 
		DACCORD_OPT="${DACCORD_OPT} -e${para}"	
	fi	
	para=$(getJobPara ${pName} daccord minOutLen)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DACCORD_OPT="${DACCORD_OPT} -l${para}"	
	fi
	para=$(getJobPara ${pName} daccord minKFreq)
	if $(isFloatNumber ${para}) 
	then 
		DACCORD_OPT="${DACCORD_OPT} --minfilterfreq${para}"	
	fi	
	para=$(getJobPara ${pName} daccord maxKFreq)
	if $(isFloatNumber ${para}) 
	then 
		DACCORD_OPT="${DACCORD_OPT} --maxfilterfreq${para}"	
	fi	
	para=$(getJobPara ${pName} daccord maxOvls)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DACCORD_OPT="${DACCORD_OPT} -D${para}"	
	fi
	para=$(getJobPara ${pName} daccord vard)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DACCORD_OPT="${DACCORD_OPT} --vard${para}"	
	fi
	para=$(getJobPara ${pName} daccord kmer)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		DACCORD_OPT="${DACCORD_OPT} -k${para}"	
	fi
}

function setComputeExtrinsicQVOptions
{
	## this sets the global array variable SLURM_RUN_PARA (partition, nCores, mem, time, step, tasks)
	getSlurmRunParameter ${pipelineStepName}
	   	        
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} computeextrinsicqv partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} computeextrinsicqv mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi

	### available options: tspace
	COMPUTEEXTRINSICQV_OPT=""
	
	para=$(getJobPara ${pName} computeextrinsicqv tspace)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		COMPUTEEXTRINSICQV_OPT="${COMPUTEEXTRINSICQV_OPT} --tspace${para}"	
	fi
}


function setHaploSplitOptions()
{
	## this sets the global array variable SLURM_RUN_PARA (partition, nCores, mem, time, step, tasks)
	getSlurmRunParameter ${pipelineStepName}
	   	        
    ### current rmask JobPara can overrule general SLURM_RUN_PARA
	para=$(getJobPara ${pipelineName} haplosplit partition)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[0]=${para}			
	fi
	para=$(getJobPara ${pipelineName} haplosplit mem)
	if [[ "x${para}" != "x" ]]
	then 
		SLURM_RUN_PARA[2]=${para}				
	fi

	### available options: type threads depth phaseThreshold maxAlns diffRate numVars numBlocks
	HAPLOSPLIT_OPT=""
	
	para=$(getJobPara ${pName} haplosplit type)
	if [[ "${para}" == "split_dis" ]]
	then 
		HAPLOSPLIT_BIN="${para}"
	elif [[ "${para}" == "split_agr" ]]
	then 
		HAPLOSPLIT_BIN="${para}"	
	else
		(>&2 echo "[WARNING] DAmar.cfg: setHaploSplitOptions(): Unknown haplosplit type ${para}. Must be set to split_agr or split_dis!");
		exit 1	
	fi
	para=$(getJobPara ${pName} haplosplit threads)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		HAPLOSPLIT_OPT="${HAPLOSPLIT_OPT} -t${para}"
		SLURM_RUN_PARA[1]=${para}	
	fi
	para=$(getJobPara ${pName} haplosplit depth)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		HAPLOSPLIT_OPT="${HAPLOSPLIT_OPT} -d${para}"	
	fi
	para=$(getJobPara ${pName} haplosplit phaseThreshold)
	if $(isFloatNumber ${para})
	then 
		HAPLOSPLIT_OPT="${HAPLOSPLIT_OPT} -p${para}"	
	fi
	para=$(getJobPara ${pName} haplosplit maxAlns)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		HAPLOSPLIT_OPT="${HAPLOSPLIT_OPT} -D${para}"	
	fi
	para=$(getJobPara ${pName} haplosplit diffRate)
	if $(isFloatNumber ${para})
	then 
		HAPLOSPLIT_OPT="${HAPLOSPLIT_OPT} --drate${para}"	
	fi
	para=$(getJobPara ${pName} haplosplit numVars)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		HAPLOSPLIT_OPT="${HAPLOSPLIT_OPT} --kv${para}"	
	fi
	para=$(getJobPara ${pName} haplosplit numVars)
	if $(isFloatNumber ${para})
	then 
		HAPLOSPLIT_OPT="${HAPLOSPLIT_OPT} --phasetype${para}"	
	fi	
	para=$(getJobPara ${pName} haplosplit numBlocks)
	if $(isNumber ${para}) && [ ${para} -gt 0 ]
	then 
		HAPLOSPLIT_NBLOCKS="${para}"
	else # set default to 10	
		HAPLOSPLIT_NBLOCKS="10"
	fi
}
